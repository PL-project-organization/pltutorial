{"author": "Dominique Revuz ", "text": "\nEcrire une fonction **pom** qui prend un parametre entier n et qui Affiche des Pom :\n\n\tSi n < 1 affiche **Pas de Pom**\n\tsinon affiche **Pom** pour n = 1\n\t      affiche **Pom Pom** pour n =2\n\t      affiche **Pom Pom Pom** pour n =\n\tetc\n\n\n", "basefiles": {"utils.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n#  utils.py\n#\n#  Copyright 2016 Dominique Revuz <dr@univ-mlv.fr>\n#\n# help functions to use in the PL project\n#\n#\n\nimport subprocess\nimport json\nimport sys\nimport re\nimport os\n\npldicsingleton=None\n\ndef getpldic():\n\t'''\n\tgetpdic return the dictionnary contained in the file \"./pl.json\"\n\t'''\n\tglobal pldicsingleton\n\tif pldicsingleton == None :\n\t\ttry:\n\t\t\tpldicsingleton= json.load(open(\"pl.json\",\"r\"))\n\t\texcept Exception as e:\n\t\t\tpldicsingleton = {\"plateforme\":False,\n\t\t\t\t\"stderr\":e,\"result\":False,\n\t\t\t\t\"stdout\":\"PlateForme IO ERROR\"}\n\treturn pldicsingleton\n\n\nglobtaboook=False # par defaut pas de problem de taboo\n\n# le checktaboo doit \u00eatre fait en debut de grader\ndef checktaboo(taboo):\n\t\"\"\"\n\tcheck taboo est brutal\n\til faudrais faire une analyse du code avec l'AST pour\n\t\u00eatre sur que les mots clefs sont vraiment des mots clef\n\tpas des truc ou les loups 'bass' sont transform\u00e9e en 'bbotom'.\n\t\"\"\"\n\tltaboo = taboo.split('|')\n\tmots = (open(\"student.py\",\"r\").read()).split() #\n\tfor x in ltaboo:\n\t\tif x in mots:\n\t\t\tglobtaboook = True\n\treturn globtaboook\n\n\n\ndef check_output(want, got):\n\t\"\"\"\n\tReturn True iff the actual output from an example (`got`)\n\tmatches the expected output (`want`).\n\n\t\"\"\"\n\n\t# If `want` contains hex-escaped character such as \"\\u1234\",\n\t# then `want` is a string of six characters(e.g. [\\,u,1,2,3,4]).\n\t# On the other hand, `got` could be another sequence of\n\t# characters such as [\\u1234], so `want` and `got` should\n\t# be folded to hex-escaped ASCII string to compare.\n\t# FIXME i commanted out the 2 following lignes\n\t# FIXME should verify if bytes then decode(utf-8) \n\tgot = str(pldecode(got).encode('ASCII', 'backslashreplace'), \"ASCII\")\n\twant = str(pldecode(want).encode('ASCII', 'backslashreplace'), \"ASCII\")\n\n\t# Handle the common case first, for efficiency:\n\t# if they're string-identical, always return true.\n\tif got == want:\n\t\treturn True\n\n\t# If a line in got contains only spaces, then remove the\n\t# spaces.\n\tgot = re.sub('(?m)^\\s*?$', '', got)\n\tif got == want:\n\t\treturn True\n\t# This flag causes doctest to ignore any differences in the\n\t# contents of whitespace strings.  Note that this can be used\n\t# in conjunction with the ELLIPSIS flag.\n\tif True : # we want normelized white spaces\n\t\tgot = ' '.join(got.split())\n\t\twant = ' '.join(want.split())\n\t\tif got == want:\n\t\t\treturn True\n\t# We didn't find any match; return false.\n\treturn False\n\n\ndef pldecode(s):\n\tif type(s) is str:\n\t\treturn s\n\telse:\n\t\treturn str(s.decode(encoding=\"utf-8\", errors=\"strict\"))\n\ndef dodump(dr,ev=0):\n\t#for key in ['execution','feedback','error','other','error']:\n\t#\tdr[key]= '<br>'.join(dr[key].split(\"\\n\"))\n\tpld=getpldic()\n\tif \"help\" in pld:\n\t\tdr['feedback'] += pld[\"help\"]\n\tprint(json.dumps(dr))\n\tsys.exit(ev)\n\n\ndef success(message):\n\tdico_reponse = { \"success\": True ,\n\t\"execution\" : \"\",\n\t\"feedback\": \"# Bravo ! \\n\\n vous avez r\u00e9ussit l'exercice\\n\"+message,\n\t\"other\": \"\",\"error\":\"\"}\n\tif globtaboook :# usage d'un mot taboo\n\t\tdico_reponse[\"success\"]= False\n\t\tdico_reponse[\"feedback\"] += \"# Taboo \\n\\nL'execution est bonne mais les taboo ne sont pas respect\u00e9s\\n recommencez sans les mots clefs :\"+getpldic()[\"taboo\"]\n\tdodump(dico_reponse)\n\n\ndef compileerror(message):\n\t\"\"\"\n\tcompileerror(\"les messages du compilateur pour l'execution \")\n\t\n\t\"\"\"\n\tmessage = \"\\n\\n\".join(pldecode(message).split(\"\\n\"))\n\tdico_reponse = { \"success\": False ,\n\t \"feedback\": \"# Erreur de compilation \\n\\n Le compilateur \u00e0 d\u00e9tect\u00e9 une erreur\\n\\n il faut la corriger\\n\\n\"+message,\"errormessages\" : \"\" , \"other\": \"\",\"error\":\"\",\"execution\":\"\" }\n\tdodump(dico_reponse)\n\ndef erreurdexecution(message):\n\t\"\"\"\n\tappellez cette fonction quand il y a une exception dans l'execution\n\ti.e. stderr non vide\n\tappeller avec la concat\u00e9nation de stdout et sdterr\n\t\"\"\"\n\tdico_reponse = { \"success\": False ,\n\t \"feedback\": \"# Erreur \u00e0 l'ex\u00e9cution\\n Il semble qu'une erreur de programmation c'est gliss\u00e9e dans votre code \\n# la Sortie standard\\n\"+str(message),\"errormessages\" : \"\" , \"other\": \"\",\"error\":\"\",\"execution\":\"\" }\n\tdodump(dico_reponse)\n\ndef failure(message):\n\t\"\"\"\n\tUne erreur d'excution r\u00e9sultat non conforme aux attentes\n\tle message contient le nombre de tests r\u00e9ussis et le test en \u00e9chec\n\t\"\"\"\n\tdico_reponse = { \"success\": False , \"errormessages\" : \"\" ,\n\t \"feedback\": \"#Mauvais r\u00e9sultat \\n Il n'y a pas d'erreur dans votre code \\n Mais il ne calcul pas le r\u00e9sultat attendu\\n # Execution \\n \"+str(message), \"other\":\"\" ,\"error\":\"\",\"execution\":\"\"}\n\tdodump(dico_reponse)\n\ndef plateform(dexec,feedback=\"# Erreur Plateforme \\n Un probl\u00e8me de la plateforme\\\\n parlez en au professeur\\\\n passez \u00e0 l'exercice suivant\"):\n\tfeedback += \"\\n# Execution \\n\" + dexec['stdout']\n\tfeedback += \"\\# Erreurs \\n\"+ dexec['stderr']+\"\\n\"+error \n\tdico_reponse = { \"success\": True , \"errormessages\" : \"\",\"feedback\": feedback, \"other\": \"\",\"error\":\"\",\"execution\": \"\"\n\t\t}\n\tdodump(dico_reponse,ev=1)\n\n\n\n\ndef exectojson(target,infile=None,jsonfile=None,timeout=1):\n\t\"\"\"\n\texectojson execute the shell process\n\tpython3 target <infile\n\tcatches the result, stdout, stderr of this process and\n\treturn a dictionnary with these three values\n\tif jsonfile != None:\n\t\ta jsondump of the dictionnary is done in the file named jsonfile\n\tthe process is kill after a timeout (1 default) seconds\n\n\n\t\t>>> d=exectojson(\"xx.py\",infile=\"entrrrrrrree.tex\")\n\t\t>>> d['result']==False\n\t\tTrue\n\t\t>>> d['stdout'] == \"PlateForme IO ERROR\"\n\t\tTrue\n\n\t\t>>> f=open(\"entree.tex\",\"r\")\n\t\t>>> d=exectojson(\"tolong.py\",infile=\"entree.tex\")\n\t\t>>> d['result']\n\t\tFalse\n\t\t>>> d['stdout']\n\t\t\"temps d'execution trop long\"\n\n\t\t>>> d=exectojson(\"xx.py\",infile=\"entree.tex\")\n\t\t>>> d['result']\n\t\tTrue\n\t\t>>> d['stdout']\n\t\t\"procesus fils\\\\nj'ai lu  PAS DE PROBLEM DE LECTURE\\\\n\"\n\t\t>>> d=exectojson(\"xx.py\") # pas d'input\n\t\t>>> d['result']\n\t\tFalse\n\t\t>>> d['stdout']\n\t\t'procesus fils\\\\n'\n\t\t>>> exectojson(['-m','doctest','testofdoc.py'])\n\t\t>>> d['result']\n\t\tTrue\n\n\t\"\"\"\n\t# TODO can i check the existance of python3 ?\n\t# CHECKME no options\n\tif isinstance(target, str):\n\t\targs=['python3',target]\n\telif isinstance(target, list):\n\t\targs=['python3']\n\t\targs.extend(target)\n\telse:\n\t\traise TypeError(target)\n\ttry:\n\t\tif infile:\n\t\t\tentry = open(infile, \"rb\")\n\t\t\tcp = subprocess.run(args, input=entry.read(),\n\t\t\t\tstdout=subprocess.PIPE,stderr=subprocess.PIPE,\n\t\t\t\ttimeout=timeout)\n\t\telse:\n\t\t\tcp = subprocess.run(args, stdin=subprocess.DEVNULL, stdout=subprocess.PIPE,stderr=subprocess.PIPE, timeout=timeout)\n\t\tdico = {\"plateforme\":True,\"stderr\":cp.stderr.decode(\"utf-8\"),\"result\":(cp.returncode==0),\"stdout\":cp.stdout.decode(\"utf-8\"),\"cp\":cp,\"pwd\":os.getcwd()}\n\t\treturn(dico)\n\texcept (OSError, IOError) as e:\n\t\tdico = {\"plateforme\":False,\"stderr\":e,\"result\":False,\"stdout\":\"PlateForme IO ERROR\"}\n\texcept subprocess.TimeoutExpired as toe:\n\t\tdico = {\"plateforme\":True,\"stderr\":toe,\"result\":False,\"stdout\":\"temps d'execution trop long\"}\n\n\tif jsonfile:\n\t\twith open(jsonfile,\"w\") as jsf:\n\t\t\tjson.dump(dico, fp=jsf,sort_keys=True)\n\treturn(dico)\n\ndef compiletest():\n\t\"\"\"\n\t>>> _createStudentCode(\"@ <- \u00e7a grosse erreur de compile \")\n\t>>> compiletest()\n\tTraceback (most recent call last):\n\t...\n\tSystemExit: 0\n\t>>> _createStudentCode(\"print('titi') \")\n\t>>> compiletest()\n\tTrue\n\t\"\"\"\n\tEEE=None\n\timport py_compile\n\ttry:\n\t\tx= py_compile.compile(\"student.py\",doraise=True)\n\texcept Exception as EE:\n\t\tEEE=EE\n\telse:\n\t\treturn True\n\n\tcompileerror(str(EEE))\n\n\n\n\n\n\n\n\ndef createInputFile(pld,lastgenerated=True):\n\t# il faut pour tous les input* verifier que l'execution de student celle de soluce\n    # ou bien faire inputgeneratorcalls appels \u00e0 inputgenerator et verifier la m\u00eame chose\n\t\"\"\"\n\tcreates a file \"input.txt\" in current directory\n\twith the inputgenerator if it exist\n\twith the input field if it exist\n\twith input0 to input9 FIXME in this order\n\tthe inputgenerator is considered random\n\t\tand new file will create each call\n\n\t>>> import os.path\n\t>>> if os.path.isfile(\"input.txt\"): os.remove(\"input.txt\")\n\t>>> plk={\"inputgenerator\":\"import random\\\\nfor  n in range(10):\\\\n  print(random.randint(4,123))\",\"input\":None}\n\t>>> createInputFile(plk,lastgenerated=True)\n\tTrue\n\t>>> \"inputgenerator\" in plk\n\tFalse\n\t>>> os.path.isfile(\"input.txt\")\n\tTrue\n\t>>> createInputFile({\"inputgenerator\":\"import random\\\\nfor  n in range(10):\\\\n  print(random.randint(4,123))\",\"input\":\"Toto\"}) # ambiguit\u00e9 entre input et inputgenerator\n\tTraceback (most recent call last):\n\t...\n\tSystemExit: 0\n\t>>> if os.path.isfile(\"input.txt\"): os.remove(\"input.txt\")\n\t>>> createInputFile({\"input\": b\"1\\\\n2\\\\n3\\\\n4\\\\n\"})\n\tTrue\n\t>>> os.path.isfile(\"input.txt\")\n\tTrue\n\t>>> createInputFile({\"input4\": b\"5\\\\n5\\\\n5\\\\n5\\\\n\"})\n\tTrue\n\t>>> createInputFile({})\n\tFalse\n\t\"\"\"\n\n\tif 'inputgenerator' in pld:\n\t\twith open(\"inputgen.py\",\"w\") as ig:\n\t\t\tprint(pld[\"inputgenerator\"],file=ig)\n\t\td=exectojson(\"inputgen.py\")\n\t\tif  'input' in pld and pld['input'] != None:\n\t\t\t# TODO remonter une erreur a l'auteur du test\n\t\t\tfailure(\"INPUT ET INPUTGENERATOR AMBIGUITE\\\\n\")\n\t\tpld['input']=d['stdout'] # on \u00e9crasse le input\n\t\tif lastgenerated:\n\t\t\tdel pld['inputgenerator'] # doit repondre faux la prochaine fois\n\telif not 'input' in pld:\n\t\tfor i in range(0,10):\n\t\t\ts='input'+str(i)\n\t\t\tif s in pld:\n\t\t\t\tpld['input']=pld[s]\n\t\t\t\tdel pld[s]\n\t\t\t\tbreak\n\n\tif 'input' in pld:\n\t\twith open(\"input.txt\",\"w\") as it :\n\t\t\tprint(pldecode(pld['input']),file=it)\n\t\t\tdel pld['input']\n\t\treturn True\n\telse:\n\t\treturn False # retourne faux si pas de input ou si fin des inputs pr\u00e9d\u00e9finis\n\n\ndef compareexecution():\n\t\"\"\"\n\tcheck the execution of student with input = input.txt\n\tagainst the execution of soluce with input = input.txt\n\t\"\"\"\n\tdt= exectojson(\"soluce.py\",infile=\"input.txt\")\n\tds= exectojson(\"student.py\",infile=\"input.txt\")\n\tif check_output(dt['stdout'],ds['stdout']):\n\t\t# TODO\n\t\treturn True,\"\",\"\"\n\telse:\n\t\treturn False,str(dt['stdout']),str(ds['stdout'])\n\ndef dumpdic(dic):\n\timport json\n\tf=open(\"pl.json\",\"w\")\n\tprint(json.dump(dic,f,sort_keys=True))\n\tf.close()\n\treturn\n\ndef _createStudentCode(code):\n\tf=open(\"student.py\",\"w\")\n\tprint(code,file=f)\n\tf.close()\n\ndef testexpectedoutput():\n\tpld=getpldic()\n\tif not createInputFile(pld): # il n'y a pas de fichier d'entr\u00e9e\n\t\td=exectojson(\"student.py\")\n\telse:\n\t\td=exectojson(\"student.py\",infile=\"input.txt\")\n\tif check_output(pld['expectedoutput'],d['stdout']):\n\t\tsuccess(pld['expectedoutput'])\n\telse:\n\t\tmessage = \"Votre script ne produit pas la bonne sortie.\\n\\nsortie attendue:\\n\" + pld['expectedoutput']\n\t\tmessage += \"\\n\\nsortie optenue:\\n\\n\" + pldecode( d['stdout'])\n\t\terreurdexecution(message)\n\n\ndef testpltest():\n\tpld=getpldic()\n\twith open(\"pltest.py\",\"w\") as pltf :\n\t\twith open(\"student.py\",\"r\") as f:\n\t\t\tprint(\"\\\"\\\"\\\"\\n\"+pld[\"pltest\"]+\"\\\"\\\"\\\"\",file=pltf)\n\t\t\tprint(f.read(),file=pltf)\n\tos.environ['TERM']=\"linux\"# bug in readlinhttps://bugs.python.org/msg191824\n\td=exectojson(['-m','doctest','pltest.py'])\n\tif d['result']:\n\t\tsuccess(\"# Bravo \\n\\nTout les tests sont pass\u00e9s \\n\\n\")\n\telse:\n\t\terreurdexecution(d['stdout'])\n\n\ndef testsoluce():\n\n\t\tNBT=0 # NOMBRE DE TESTS REUSSIT\n\t\twhile createInputFile(pld) :\n\t\t\tr,want,got = compareexecution()\n\t\t\tif not r : # echec d'un test\n\t\t\t\tmessage= \"# \"+ str(NBT)+\" tests r\u00e9ussits\\n\"\n\t\t\t\tmessage += \"entree:\\n\"\n\t\t\t\tmessage += open(\"input.txt\",\"r\").read()\n\t\t\t\tmessage += \"\\nsortie attendue:\\n\" + str(want)\n\t\t\t\tmessage += \"\\nsortie optenue:\\n\" + str(got)\n\t\t\t\tfailure(message)\n\t\t\telse:\n\t\t\t\tNBT+=1\n\t\tmessage=\"%d tests pass\u00e9 avec succes \" % NBT\n\t\tsuccess(message)\n\ndef grade():\n\t\"\"\"\n\t# pour que ce test fonctionne il faut un fichier pl.json\n\t>>> dumpdic({\"input\":\"1\\\\n2\\\\n\",\"expectedoutput\":\"1\\\\n2\\\\n\"})\n\tNone\n\t>>> _createStudentCode(\"print(input())\\\\nprint(input())\\\\n\")\n\t>>> d=grade()\n\tTraceback (most recent call last):\n\t...\n\tSystemExit: 0\n\t>>>\n\t\"\"\"\n\tpld=getpldic()\n\tif 'taboo' in pld:\n\t\tchecktaboo(pld['taboo'])\n\tcompiletest()\n\tif 'expectedoutput' in pld:\n\t\treturn testexpectedoutput()\n\telif 'pltest' in pld:\n\t\treturn testpltest()\n\telif 'soluce' in pld:\n\t\treturn testsoluce()\n\telse:\n\t\tplateform(message=\"Utilisez une m\u00e9thode d'\u00e9valuation expectedoutput,pltest,soluce\\\\n\")\n\n\ndef main(args):\n\tprint(\"ce fichier n'est pas un script principal\",file=sys.stderr)\n\treturn 1\n\nif __name__ == '__main__':\n    import sys\n    sys.exit(main(sys.argv))\n", "gag.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#  gag.py\n#  \n#  Copyright 2016 Dominique Revuz <dr@univ-mlv.fr>\n#  \n\nimport subprocess\n\n\n\ndef dorun():\n\treturn subprocess.run([\"python3\",\"-m\",\"doctest\",\"pltest.py\"], stdin=subprocess.DEVNULL,stdout=subprocess.PIPE,stderr=subprocess.PIPE, timeout=1)\n\nif __name__ == \"__main__\":\n\tprint(dorun())\n\n\n"}, "pltest": ">>> pom(0)\n'Pas de Pom'\n>>> pom(1) # pas d'espace dans la solution \n'Pom'\n>>> pom(1) # pas d'espace \u00e0 la fin\n'Pom'\n>>> pom(12) # plein de pomme \n'Pom Pom Pom Pom Pom Pom Pom Pom Pom Pom Pom Pom'\n>>> pom(-777) #vraiment n\u00e9gatif\n'Pas de Pom'\n", "grader": "from utils import grade\ngrade()\n", "tag": "# N'oubliez pas de remplir ce champs svp", "title": "Pom Pom Pom Pom  ", "name": "pom.pl", "testcode": "def pom(n):\n\tif n>0:\n\t\tprint(\"Pom \"*(n-1)+\"Pom\")\n\telse:\n\t\tprint(\"Pas de Pom\")\n"}