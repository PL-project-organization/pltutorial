{"grader": "from utils import grade\ngrade()\n", "soluce": "nbreoeufs = int( input(\"saississez le nombre d'oeufs :\") )\n\nprint(\"Il faut \"+ nbroeufs // 6 + \"boites.\")\nprint(\"il restera \"+ nbroeufs % 6 + \"oeufs.\") \n\n", "name": "Boites d'oeufs", "inputgenerator": "from random import randint\n\nprint(randint(10,100))\n", "basefiles": {"gag.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#  gag.py\n#  \n#  Copyright 2016 Dominique Revuz <dr@univ-mlv.fr>\n#  \n#  This program is free software; you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation; either version 2 of the License, or\n#  (at your option) any later version.\n#  \n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#  \n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n#  MA 02110-1301, USA.\n#  \n#  \n\nimport subprocess\n\n\nprint(subprocess.run([\"python3\",\"-m\",\"doctest\",\"pltest.py\"]))\n", "toto.ty": "#######\n\n\n######\n\n\n######\n", "utils.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n#  utils.py\n#\n#  Copyright 2016 Dominique Revuz <dr@univ-mlv.fr>\n#\n# help functions to use in the PL project\n#\n#\n\nimport subprocess\nimport json\nimport sys\nimport re\nimport os\n\npldicsingleton=None\n\ndef getpldic():\n\t'''\n\tgetpdic return the dictionnary contained in the file \"./pl.json\"\n\t'''\n\tglobal pldicsingleton\n\tif pldicsingleton == None :\n\t\ttry:\n\t\t\tpldicsingleton= json.load(open(\"pl.json\",\"r\"))\n\t\texcept Exception as e:\n\t\t\tpldicsingleton = {\"plateforme\":False,\n\t\t\t\t\"stderr\":e,\"result\":False,\n\t\t\t\t\"stdout\":\"PlateForme IO ERROR\"}\n\treturn pldicsingleton\n\n\nglobtaboook=False # par defaut pas de problem de taboo\n\n# le checktaboo doit \u00eatre fait en debut de grader\ndef checktaboo(taboo):\n\t\"\"\"\n\tcheck taboo est brutal\n\til faudrais faire une analyse du code avec l'AST pour\n\t\u00eatre sur que les mots clefs sont vraiment des mots clef\n\tpas des truc ou les loups 'bass' sont transform\u00e9e en 'bbotom'.\n\t\"\"\"\n\tltaboo = taboo.split('|')\n\tmots = (open(\"student.py\",\"r\").read()).split() #\n\tfor x in ltaboo:\n\t\tif x in mots:\n\t\t\tglobtaboook = True\n\treturn globtaboook\n\n\n\ndef check_output(want, got):\n\t\"\"\"\n\tReturn True iff the actual output from an example (`got`)\n\tmatches the expected output (`want`).\n\n\t\"\"\"\n\n\t# If `want` contains hex-escaped character such as \"\\u1234\",\n\t# then `want` is a string of six characters(e.g. [\\,u,1,2,3,4]).\n\t# On the other hand, `got` could be another sequence of\n\t# characters such as [\\u1234], so `want` and `got` should\n\t# be folded to hex-escaped ASCII string to compare.\n\t# FIXME i commanted out the 2 following lignes\n\t# FIXME should verify if bytes then decode(utf-8) \n\tgot = str(pldecode(got).encode('ASCII', 'backslashreplace'), \"ASCII\")\n\twant = str(pldecode(want).encode('ASCII', 'backslashreplace'), \"ASCII\")\n\n\t# Handle the common case first, for efficiency:\n\t# if they're string-identical, always return true.\n\tif got == want:\n\t\treturn True\n\n\t# If a line in got contains only spaces, then remove the\n\t# spaces.\n\tgot = re.sub('(?m)^\\s*?$', '', got)\n\tif got == want:\n\t\treturn True\n\t# This flag causes doctest to ignore any differences in the\n\t# contents of whitespace strings.  Note that this can be used\n\t# in conjunction with the ELLIPSIS flag.\n\tif True : # we want normelized white spaces\n\t\tgot = ' '.join(got.split())\n\t\twant = ' '.join(want.split())\n\t\tif got == want:\n\t\t\treturn True\n\t# We didn't find any match; return false.\n\treturn False\n\n\ndef pldecode(s):\n\tif type(s) is str:\n\t\treturn s\n\telse:\n\t\treturn str(s.decode(encoding=\"utf-8\", errors=\"strict\"))\n\ndef dodump(dr,ev=0):\n\t#for key in ['execution','feedback','error','other','error']:\n\t#\tdr[key]= '<br>'.join(dr[key].split(\"\\n\"))\n\tpld=getpldic()\n\tif \"help\" in pld:\n\t\tdr['feedback'] += pld[\"help\"]\n\tprint(json.dumps(dr))\n\tsys.exit(ev)\n\n\ndef success(message):\n\tdico_reponse = { \"success\": True ,\n\t\"execution\" : \"\",\n\t\"feedback\": \"# Bravo ! \\n\\n vous avez r\u00e9ussit l'exercice\\n\"+message,\n\t\"other\": \"\",\"error\":\"\"}\n\tif globtaboook :# usage d'un mot taboo\n\t\tdico_reponse[\"success\"]= False\n\t\tdico_reponse[\"feedback\"] += \"# Taboo \\n\\nL'execution est bonne mais les taboo ne sont pas respect\u00e9s\\n recommencez sans les mots clefs :\"+getpldic()[\"taboo\"]\n\tdodump(dico_reponse)\n\n\ndef compileerror(message):\n\t\"\"\"\n\tcompileerror(\"les messages du compilateur pour l'execution \")\n\n\t\"\"\"\n\tmessage = \"\\n\\n\".join(pldecode(message).split(\"\\n\"))\n\tdico_reponse = { \"success\": False ,\n\t \"feedback\": \"# Erreur de compilation \\n\\n Le compilateur \u00e0 d\u00e9tect\u00e9 une erreur\\n\\n il faut la corriger\\n\\n\"+message,\"errormessages\" : \"\" , \"other\": \"\",\"error\":\"\",\"execution\":\"\" }\n\tdodump(dico_reponse)\n\ndef erreurdexecution(message):\n\t\"\"\"\n\tappellez cette fonction quand il y a une exception dans l'execution\n\ti.e. stderr non vide\n\tappeller avec la concat\u00e9nation de stdout et sdterr\n\t\"\"\"\n\tdico_reponse = { \"success\": False ,\n\t \"feedback\": \"# Erreur \u00e0 l'ex\u00e9cution\\n Il semble qu'une erreur de programmation c'est gliss\u00e9e dans votre code \\n# la Sortie standard\\n\"+str(message),\"errormessages\" : \"\" , \"other\": \"\",\"error\":\"\",\"execution\":\"\" }\n\tdodump(dico_reponse)\n\ndef failure(message):\n\t\"\"\"\n\tUne erreur d'excution r\u00e9sultat non conforme aux attentes\n\tle message contient le nombre de tests r\u00e9ussis et le test en \u00e9chec\n\t\"\"\"\n\tdico_reponse = { \"success\": False , \"errormessages\" : \"\" ,\n\t \"feedback\": \"#Mauvais r\u00e9sultat \\n Il n'y a pas d'erreur dans votre code \\n Mais il ne calcul pas le r\u00e9sultat attendu\\n # Execution \\n \"+str(message), \"other\":\"\" ,\"error\":\"\",\"execution\":\"\"}\n\tdodump(dico_reponse)\n\ndef plateform(dexec,feedback=\"# Erreur Plateforme \\n Un probl\u00e8me de la plateforme\\\\n parlez en au professeur\\\\n passez \u00e0 l'exercice suivant\"):\n\tfeedback += \"\\n# Execution \\n\" + dexec['stdout']\n\tfeedback += \"\\# Erreurs \\n\"+ dexec['stderr']+\"\\n\"+error \n\tdico_reponse = { \"success\": True , \"errormessages\" : \"\",\"feedback\": feedback, \"other\": \"\",\"error\":\"\",\"execution\": \"\"\n\t\t}\n\tdodump(dico_reponse,ev=1)\n\n\n\n\ndef exectojson(target,infile=None,jsonfile=None,timeout=1):\n\t\"\"\"\n\texectojson execute the shell process\n\tpython3 target <infile\n\tcatches the result, stdout, stderr of this process and\n\treturn a dictionnary with these three values\n\tif jsonfile != None:\n\t\ta jsondump of the dictionnary is done in the file named jsonfile\n\tthe process is kill after a timeout (1 default) seconds\n\n\n\t\t>>> d=exectojson(\"xx.py\",infile=\"entrrrrrrree.tex\")\n\t\t>>> d['result']==False\n\t\tTrue\n\t\t>>> d['stdout'] == \"PlateForme IO ERROR\"\n\t\tTrue\n\n\t\t>>> f=open(\"entree.tex\",\"r\")\n\t\t>>> d=exectojson(\"tolong.py\",infile=\"entree.tex\")\n\t\t>>> d['result']\n\t\tFalse\n\t\t>>> d['stdout']\n\t\t\"temps d'execution trop long\"\n\n\t\t>>> d=exectojson(\"xx.py\",infile=\"entree.tex\")\n\t\t>>> d['result']\n\t\tTrue\n\t\t>>> d['stdout']\n\t\tb\"procesus fils\\\\nj'ai lu  PAS DE PROBLEM DE LECTURE\\\\n\"\n\t\t>>> d=exectojson(\"xx.py\") # pas d'input\n\t\t>>> d['result']\n\t\tFalse\n\t\t>>> d['stdout']\n\t\tb'procesus fils\\\\n'\n\t\t>>> d=exectojson(['-m','doctest','testofdoc.py'])\n\t\t>>> d['result']\n\t\tTrue\n\n\t\"\"\"\n\t# TODO can i check the existance of python3 ?\n\t# CHECKME no options\n\tif isinstance(target, str):\n\t\targs=['python3',target]\n\telif isinstance(target, list):\n\t\targs=['python3']\n\t\targs.extend(target)\n\telse:\n\t\traise TypeError(target)\n\ttry:\n\t\tif infile:\n\t\t\tentry = open(infile, \"rb\")\n\t\t\tcp = subprocess.run(args, input=entry.read(),\n\t\t\t\tstdout=subprocess.PIPE,stderr=subprocess.PIPE,\n\t\t\t\ttimeout=timeout)\n\t\telse:\n\t\t\tcp = subprocess.run(args, stdin=subprocess.DEVNULL, stdout=subprocess.PIPE,stderr=subprocess.PIPE, timeout=timeout)\n\t\tdico = {\"plateforme\":True,\"stderr\":cp.stderr.decode(\"utf-8\"),\"result\":(cp.returncode==0),\"stdout\":cp.stdout.decode(\"utf-8\"),\"cp\":cp,\"pwd\":os.getcwd()}\n\t\treturn(dico)\n\texcept (OSError, IOError) as e:\n\t\tdico = {\"plateforme\":False,\"stderr\":e,\"result\":False,\"stdout\":\"PlateForme IO ERROR\"}\n\texcept subprocess.TimeoutExpired as toe:\n\t\tdico = {\"plateforme\":True,\"stderr\":toe,\"result\":False,\"stdout\":\"temps d'execution trop long\"}\n\n\tif jsonfile:\n\t\twith open(jsonfile,\"w\") as jsf:\n\t\t\tjson.dump(dico, fp=jsf,sort_keys=True)\n\treturn(dico)\n\ndef compiletest():\n\t\"\"\"\n\t>>> _createStudentCode(\"@ <- \u00e7a grosse erreur de compile \")\n\t>>> compiletest()\n\tTraceback (most recent call last):\n\t...\n\tSystemExit: 0\n\t>>> _createStudentCode(\"print('titi') \")\n\t>>> compiletest()\n\tTrue\n\t\"\"\"\n\tEEE=None\n\timport py_compile\n\ttry:\n\t\tx= py_compile.compile(\"student.py\",doraise=True)\n\texcept Exception as EE:\n\t\tEEE=EE\n\telse:\n\t\treturn True\n\n\tcompileerror(str(EEE))\n\treturn False # inatt\u00e9gnable\n\n\n\n\n\n\n\ndef createInputFile(pld,lastgenerated=True):\n\t\"\"\"\n\tcreates a file \"input.txt\" in current directory\n\twith the inputgenerator if it exist\n\twith the input field if it exist\n\twith input0 to input9 FIXME in this order\n\tthe inputgenerator is considered random\n\t\tand new file will create each call\n\n\t>>> import os.path\n\t>>> if os.path.isfile(\"input.txt\"): os.remove(\"input.txt\")\n\t>>> plk={\"inputgenerator\":\"import random\\\\nfor  n in range(10):\\\\n  print(random.randint(4,123))\",\"input\":None}\n\t>>> createInputFile(plk,lastgenerated=True)\n\tTrue\n\t>>> \"inputgenerator\" in plk\n\tFalse\n\t>>> os.path.isfile(\"input.txt\")\n\tTrue\n\t>>> createInputFile({\"inputgenerator\":\"import random\\\\nfor  n in range(10):\\\\n  print(random.randint(4,123))\",\"input\":\"Toto\"}) # ambiguit\u00e9 entre input et inputgenerator\n\tTraceback (most recent call last):\n\t...\n\tSystemExit: 0\n\t>>> if os.path.isfile(\"input.txt\"): os.remove(\"input.txt\")\n\t>>> createInputFile({\"input\": b\"1\\\\n2\\\\n3\\\\n4\\\\n\"})\n\tTrue\n\t>>> os.path.isfile(\"input.txt\")\n\tTrue\n\t>>> createInputFile({\"input4\": b\"5\\\\n5\\\\n5\\\\n5\\\\n\"})\n\tTrue\n\t>>> createInputFile({})\n\tFalse\n\t\"\"\"\n\n\tif 'inputgenerator' in pld:\n\t\twith open(\"inputgen.py\",\"w\") as ig:\n\t\t\tprint(pld[\"inputgenerator\"],file=ig)\n\t\td=exectojson(\"inputgen.py\")\n\t\tif  'input' in pld and pld['input'] != None:\n\t\t\t# TODO remonter une erreur a l'auteur du test\n\t\t\tfailure(\"INPUT ET INPUTGENERATOR AMBIGUITE\\\\n\")\n\t\tpld['input']=d['stdout'] # on \u00e9crasse le input\n\t\tif lastgenerated:\n\t\t\tdel pld['inputgenerator'] # doit repondre faux la prochaine fois\n\telif not 'input' in pld:\n\t\tfor i in range(0,10):\n\t\t\ts='input'+str(i)\n\t\t\tif s in pld:\n\t\t\t\tpld['input']=pld[s]\n\t\t\t\tdel pld[s]\n\t\t\t\tbreak\n\n\tif 'input' in pld:\n\t\twith open(\"input.txt\",\"w\") as it :\n\t\t\tprint(pldecode(pld['input']),file=it)\n\t\t\tdel pld['input']\n\t\treturn True\n\telse:\n\t\treturn False # retourne faux si pas de input ou si fin des inputs pr\u00e9d\u00e9finis\n\n\ndef compareexecution():\n\t\"\"\"\n\tcheck the execution of student with input = input.txt\n\tagainst the execution of soluce with input = input.txt\n\t\"\"\"\n\tdt= exectojson(\"soluce.py\",infile=\"input.txt\")\n\tds= exectojson(\"student.py\",infile=\"input.txt\")\n\tif check_output(dt['stdout'],ds['stdout']):\n\t\t# TODO\n\t\treturn True,\"\",\"\"\n\telse:\n\t\treturn False,str(dt['stdout']),str(ds['stdout'])\n\ndef dumpdic(dic):\n\timport json\n\tf=open(\"pl.json\",\"w\")\n\tprint(json.dump(dic,f,sort_keys=True))\n\tf.close()\n\treturn\n\ndef _createStudentCode(code):\n\tf=open(\"student.py\",\"w\")\n\tprint(code,file=f)\n\tf.close()\n\n\ndef grade():\n\t\"\"\"\n\t# pour que ce test fonctionne il faut un fichier pl.json\n\t>>> dumpdic({\"input\":\"1\\\\n2\\\\n\",\"expectedoutput\":\"1\\\\n2\\\\n\"})\n\tNone\n\t>>> _createStudentCode(\"print(input())\\\\nprint(input())\\\\n\")\n\t>>> d=grade()\n\tTraceback (most recent call last):\n\t...\n\tSystemExit: 0\n\t>>>\n\t\"\"\"\n\tpld=getpldic()\n\tif 'taboo' in pld:\n\t\tchecktaboo(pld['taboo'])\n\tcompiletest()\n\tif 'expectedoutput' in pld:\n\t\tif not createInputFile(pld): # il n'y a pas de fichier d'entr\u00e9e\n\t\t\td=exectojson(\"student.py\")\n\t\telse:\n\t\t\td=exectojson(\"student.py\",infile=\"input.txt\")\n\t\tif check_output(pld['expectedoutput'],d['stdout']):\n\t\t\tsuccess(pld['expectedoutput'])\n\t\telse:\n\t\t\tmessage = \"Votre script ne produit pas la bonne sortie.\\n\\nsortie attendue:\\n\" + pld['expectedoutput']\n\t\t\tmessage += \"\\n\\nsortie optenue:\\n\\n\" + pldecode( d['stdout'])\n\t\t\terreurdexecution(message)\n\telif 'pltest' in pld:\n\t\twith open(\"pltest.py\",\"w\") as pltf :\n\t\t\twith open(\"student.py\",\"r\") as f:\n\t\t\t\tprint(\"\\\"\\\"\\\"\",file=pltf)\n\t\t\t\tprint(pld[\"pltest\"]+\"\\\"\\\"\\\"\\n\",file=pltf)\n\t\t\t\tprint(f.read(),file=pltf)\n\t\t\t\tos.environ['TERM']=\"linux\"\n\t\t\t\td=exectojson(\"gag.py\")\n\t\t\t\tprint(d)\n\t\t\t\tif d['result']:\n\t\t\t\t\tsuccess(\"# Bravo \\n\\nTout les tests sont pass\u00e9s \\n\\n\")\n\t\t\t\telse:\n\t\t\t\t\terreurdexecution(d['stdout']+\"    \\n\\n\"+d['stderr'])\n\telif 'soluce' in pld:\n# il faut pour tous les input* verifier que l'execution de student celle de soluce\n# ou bien faire inputgeneratorcalls appels \u00e0 inputgenerator et verifier la m\u00eame chose\n\t\tNBT=0 # NOMBRE DE TESTS REUSSIT\n\t\twhile createInputFile(pld) :\n\t\t\tr,want,got = compareexecution()\n\t\t\tif not r : # echec d'un test\n\t\t\t\tmessage= \"# \"+ str(NBT)+\" tests r\u00e9ussits\\n\"\n\t\t\t\tmessage += \"entree:\\n\"\n\t\t\t\tmessage += open(\"input.txt\",\"r\").read()\n\t\t\t\tmessage += \"\\nsortie attendue:\\n\" + str(want)\n\t\t\t\tmessage += \"\\nsortie optenue:\\n\" + str(got)\n\t\t\t\tfailure(message)\n\t\t\telse:\n\t\t\t\tNBT+=1\n\t\tmessage=\"%d tests pass\u00e9 avec succes \" % NBT\n\t\tsuccess(message)\n\telse:\n\t\tplateform(message=\"Utilisez une m\u00e9thode d'\u00e9valuation expectedoutput,pltest,soluce\\\\n\")\n\n\ndef main(args):\n\tprint(\"ce fichier n'est pas un script principal\",file=sys.stderr)\n\treturn 1\n\nif __name__ == '__main__':\n    import sys\n    sys.exit(main(sys.argv))\n"}, "author": "Dominique Revuz ", "title": "Modulo et Diviser", "code": "nbreoeufs = int( input(\"saississez le nombre d'oeufs :\") )\n\nprint(\"Il faut \"+ 333 + \"boites.\")\nprint(\"il restera \"+ 222 + \"oeufs.\") \n\n\n", "text": "\n# Operator  // et % \n\nJoelle a des poules tout les matins elle ramasse les oeufs et les mets dans des boites.\n\nQuand elle a fini de ramasser les oeufs elle appelle sont fils Emile en lui donnant le nombre d'oeufs pondus pendant la nuit, il doit calculer le nombre de boites de 6 oeufs et le nombre d'oeufs restants.\n\nAidons le avec // qui est la division enti\u00e8re et % (operateur modulo) qui calcul le reste de la division entiere. \n\nRemarque: Vieux sujet de CM2. \n", "tag": "print|input|operator.mod|operator.floordiv"}